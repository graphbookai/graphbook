from typing import Dict, List, Any
import asyncio
import time
import multiprocessing as mp
import queue
import copy
import psutil
from .utils import MP_WORKER_TIMEOUT, get_gpu_util


class Viewer:
    def __init__(self, event_name: str):
        self.event_name = event_name

    def get_event_name(self):
        return self.event_name

    def handle_outputs(self, node_id: str, outputs: dict):
        pass

    def handle_start(self, node_id: str):
        pass

    def handle_end(self):
        pass

    def handle_clear(self, node_id: str):
        pass

    def get_next(self):
        return None


class DataViewer(Viewer):
    """
    This class is used to store the a preview of the notes that are generated by the steps in the pipeline
    so that the data can be displayed in the web interface.
    """

    def __init__(self):
        super().__init__("view")
        self.last_outputs: Dict[str, dict] = {}
        self.filename = None

    def handle_outputs(self, node_id: str, output: dict):
        if node_id not in self.last_outputs:
            self.last_outputs[node_id] = {}
        new_entries = {k: v[0] for k, v in output.items() if len(v) > 0}
        self.last_outputs[node_id] |= new_entries

    def set_filename(self, filename: str):
        if filename != self.filename:
            self.filename = filename
            self.last_outputs = {}

    def handle_clear(self, node_id: str | None = None):
        if node_id is None:
            self.last_outputs = {}
        if node_id in self.last_outputs:
            del self.last_outputs[node_id]

    def get_next(self):
        return self.last_outputs


class NodeStatsViewer(Viewer):
    """
    NodeStatsViewer (for tracking stats of the pipeline, e.g. time taken per step, memory usage, queue sizes.)
    """

    def __init__(self):
        super().__init__("stats")
        self.queue_sizes: Dict[str, dict] = {}
        self.record_rate: Dict[str, float] = {}
        self.start_times: Dict[str, float] = {}
        self.execution_times: Dict[str, float] = {}
        self.total_execution_time: float = 0

    def handle_start(self, node_id: str):
        self.start_times[node_id] = time.time()

    def handle_end(self):
        self.start_times = {}

    def handle_queue_size(self, node_id: str, sizes: dict):
        self.queue_sizes[node_id] = sizes

    def get_total_queue_size(self, node_id: str):
        return sum(self.queue_sizes[node_id].values())

    def handle_outputs(self, node_id: str, outputs: dict):
        if node_id not in self.start_times:
            return
        self.record_rate[node_id] = self.get_total_queue_size(node_id) / (
            time.time() - self.start_times[node_id]
        )

    def handle_time(self, node_id: str, time: float):
        self.total_execution_time += time
        self.execution_times[node_id] = self.execution_times.get(node_id, 0) + time

    def get_next(self):
        data_obj = {}
        for node_id in self.record_rate:
            data_obj[node_id] = {
                "record_rate": self.record_rate[node_id],
            }
        for node_id in self.queue_sizes:
            data_obj.setdefault(node_id, {})
            data_obj[node_id]["queue_size"] = self.queue_sizes[node_id]
        for node_id in self.execution_times:
            data_obj.setdefault(node_id, {})
            if self.total_execution_time > 0:
                data_obj[node_id]["execution"] = (
                    self.execution_times[node_id] / self.total_execution_time
                )
        return data_obj


class NodeLogsViewer(Viewer):
    """
    Updates client with new set of incoming logs
    """

    def __init__(self):
        super().__init__("logs")
        self.logs: Dict[str, List[str]] = {}

    def handle_start(self, node_id: str):
        if node_id not in self.logs:
            self.logs[node_id] = []
        self.logs[node_id].append({"type": "wipe"})

    def handle_log(self, node_id: str, log: str, type: str = "info"):
        if node_id not in self.logs:
            self.logs[node_id] = []
        self.logs[node_id].append({"type": type, "msg": log})

    def get_next(self):
        logs = copy.deepcopy(self.logs)
        self.logs = {}
        return logs


class SystemUtilViewer(Viewer):
    """
    Tracks system utilization: CPU util, CPU memory, GPU util, GPU memory
    """

    def __init__(self, processor):
        super().__init__("system_util")
        self.processor = processor

    def get_cpu_usage(self):
        return psutil.cpu_percent()

    def get_mem_usage(self):
        return psutil.virtual_memory().percent

    def get_gpu_usage(self):
        gpus = get_gpu_util()
        return gpus

    def get_next(self):
        sizes = self.processor.get_worker_queue_sizes()
        return {
            "cpu": self.get_cpu_usage(),
            "mem": self.get_mem_usage(),
            "gpu": self.get_gpu_usage(),
            "worker_queue_sizes": sizes,
        }


class PromptViewer(Viewer):
    def __init__(self):
        super().__init__("prompt")
        self.prompts = {}

    def handle_prompt(self, node_id: str, prompt: dict):
        prev_prompt = self.prompts.get(node_id)
        idx = 0
        if prev_prompt:
            idx = prev_prompt["idx"] + 1
        prompt["idx"] = idx
        self.prompts[node_id] = prompt

    def get_next(self):
        return self.prompts


class ViewManager:
    def __init__(
        self,
        work_queue: mp.Queue,
        processor,
    ):
        self.data_viewer = DataViewer()
        self.node_stats_viewer = NodeStatsViewer()
        self.logs_viewer = NodeLogsViewer()
        self.system_util_viewer = SystemUtilViewer(processor)
        self.prompt_viewer = PromptViewer()
        self.viewers: List[Viewer] = [
            self.data_viewer,
            self.node_stats_viewer,
            self.logs_viewer,
            self.system_util_viewer,
            self.prompt_viewer,
        ]
        self.states: Dict[str, Any] = {}
        self.work_queue = work_queue
        self.close_event = mp.Event()

    def get_viewers(self):
        return self.viewers

    def handle_outputs(self, node_id: str, outputs: dict):
        if len(outputs) == 0:
            return
        for viewer in self.viewers:
            viewer.handle_outputs(node_id, outputs)

    def handle_time(self, node_id: str, time: float):
        self.node_stats_viewer.handle_time(node_id, time)

    def handle_queue_size(self, node_id: str, size: int):
        self.node_stats_viewer.handle_queue_size(node_id, size)

    def handle_start(self, node_id: str):
        for viewer in self.viewers:
            viewer.handle_start(node_id)

    def handle_clear(self, node_id: str | None):
        for viewer in self.viewers:
            viewer.handle_clear(node_id)

    def handle_log(self, node_id: str, log: str, type: str):
        self.logs_viewer.handle_log(node_id, log, type)

    def handle_prompt(self, node_id: str, prompt: dict):
        self.prompt_viewer.handle_prompt(node_id, prompt)

    def handle_end(self):
        for viewer in self.viewers:
            viewer.handle_end()

    def set_state(self, type: str, data: Any = None):
        """
        Set state data for a specific type
        """
        self.states[type] = data

    def get_current_states(self):
        """
        Retrieve all current state data
        """
        states = [{"type": key, "data": self.states[key]} for key in self.states]
        self.states.clear()
        return states

    def get_current_view_data(self):
        """
        Get the current data from all viewer classes
        """
        view_data = []
        for viewer in self.viewers:
            next_entry = viewer.get_next()
            if next_entry is not None:
                entry = {"type": viewer.get_event_name(), "data": next_entry}
                view_data.append(entry)
        return view_data

    def _loop(self):
        while not self.close_event.is_set():
            try:
                work = self.work_queue.get(timeout=MP_WORKER_TIMEOUT)
                if work["cmd"] == "handle_outputs":
                    self.handle_outputs(work["node_id"], work["outputs"])
                elif work["cmd"] == "handle_queue_size":
                    self.handle_queue_size(work["node_id"], work["size"])
                elif work["cmd"] == "handle_time":
                    self.handle_time(work["node_id"], work["time"])
                elif work["cmd"] == "handle_start":
                    self.handle_start(work["node_id"])
                elif work["cmd"] == "handle_end":
                    self.handle_end()
                elif work["cmd"] == "handle_log":
                    self.handle_log(work["node_id"], work["log"], work["type"])
                elif work["cmd"] == "handle_clear":
                    self.handle_clear(work["node_id"])
                elif work["cmd"] == "handle_prompt":
                    self.handle_prompt(work["node_id"], work["prompt"])
                elif work["cmd"] == "set_state":
                    self.set_state(work["type"], work["data"])
            except queue.Empty:
                pass

    def start(self):
        loop = asyncio.new_event_loop()
        loop.run_in_executor(None, self._loop)
        
    def stop(self):
        self.close_event.set()


class ViewManagerInterface:
    def __init__(self, view_manager_queue: mp.Queue):
        self.view_manager_queue = view_manager_queue

    def handle_log(self, node_id: str, log: str, type: str = "info"):
        self.view_manager_queue.put(
            {"cmd": "handle_log", "node_id": node_id, "log": log, "type": type}
        )

    def handle_outputs(self, node_id: str, outputs: dict):
        if len(outputs) == 0:
            return
        self.view_manager_queue.put(
            {"cmd": "handle_outputs", "node_id": node_id, "outputs": outputs}
        )

    def handle_time(self, node_id: str, time: float):
        self.view_manager_queue.put(
            {"cmd": "handle_time", "node_id": node_id, "time": time}
        )

    def handle_queue_size(self, node_id: str, size: dict):
        self.view_manager_queue.put(
            {"cmd": "handle_queue_size", "node_id": node_id, "size": size}
        )

    def handle_start(self, node_id: str):
        self.view_manager_queue.put({"cmd": "handle_start", "node_id": node_id})

    def handle_end(self):
        self.view_manager_queue.put({"cmd": "handle_end"})

    def handle_clear(self, node_id: str | None):
        self.view_manager_queue.put({"cmd": "handle_clear", "node_id": node_id})

    def handle_prompt(self, node_id: str, prompt: dict):
        self.view_manager_queue.put(
            {"cmd": "handle_prompt", "node_id": node_id, "prompt": prompt}
        )

    def set_state(self, type: str, data: Any):
        self.view_manager_queue.put({"cmd": "set_state", "type": type, "data": data})
